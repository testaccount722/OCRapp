<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scanneur OCR — Numéro (Auto)</title>
<style>
  :root {
    --accent: rgba(255,255,255,0.95);
    --frame-size-w: 360px;
    --frame-size-h: 100px;
    --error-color: #e74c3c;
  }
  html,body{ height:100%; margin:0; font-family: "Segoe UI", Roboto, Arial, sans-serif; background:#000; -webkit-tap-highlight-color: transparent; }

  #scanner { position:relative; height:100vh; width:100vw; overflow:hidden; }

  #camera-wrapper { position:absolute; inset:0; display:block; touch-action: manipulation; cursor: crosshair; }
  video#video { position: absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: none; }

  .topbar { position:absolute; top:12px; left:50%; transform:translateX(-50%); z-index:20; text-align:center; pointer-events:none; }
  .topbar .brand { display:flex; align-items:center; gap:8px; justify-content:center; color:var(--accent); font-weight:700; font-size:18px; letter-spacing:0.3px; }
  .topbar .brand img { width:28px; height:28px; object-fit:contain; filter:brightness(0) invert(1); }
  .topbar .title { margin:6px 0 0; color:var(--accent); font-size:14px; font-weight:600; opacity:0.95; pointer-events:none; }

  .overlay { position:absolute; inset:0; z-index:10; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .frame { width:var(--frame-size-w); height:var(--frame-size-h); border-radius:8px; box-shadow: 0 0 0 9999px rgba(0,0,0,0.25); border: 2px dashed rgba(255,255,255,0.95); display:flex; align-items:center; justify-content:center; position:relative; box-sizing:border-box; background: linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); backdrop-filter: blur(2px); animation: pulse 2.5s infinite; }
  .frame::after{ content:""; position:absolute; inset: -14px; border-radius: 12px; pointer-events:none; }
  @keyframes pulse{ 0%{ transform: scale(1); opacity:1;} 50%{ transform: scale(1.01); opacity:0.95;} 100%{ transform: scale(1); opacity:1;} }

  .controls { position:absolute; left:50%; transform:translateX(-50%); z-index:30; width:100%; max-width:520px; display:flex; flex-direction:column; align-items:center; gap:8px; bottom:22px; padding:0 18px; box-sizing:border-box; pointer-events:auto; }
  #result { width:100%; max-width:420px; padding:12px 14px; font-size:18px; border-radius:10px; border:2px solid rgba(0,0,0,0); outline:none; box-shadow: 0 6px 18px rgba(0,0,0,0.5); background: rgba(255,255,255,0.95); text-align:center; -webkit-appearance: none; appearance: none; }
  #result.invalid { border-color: var(--error-color); box-shadow: 0 6px 18px rgba(231,76,60,0.18); }

  #validate { width:170px; padding:10px 14px; font-size:16px; font-weight:700; border-radius:10px; border:none; cursor:pointer; box-shadow: 0 6px 18px rgba(0,0,0,0.45); background: #ffffffcc; }

  .error-msg { display:none; font-size:14px; color: var(--error-color); background: white; padding:8px 12px; border-radius:8px; box-shadow: 0 4px 10px rgba(0,0,0,0.35); max-width:420px; text-align:center; }
  .error-msg.show { display:block; animation: fadeIn .18s ease; }
  @keyframes fadeIn { from { opacity: 0; transform: translateY(6px); } to { opacity: 1; transform: translateY(0); } }

  .loader { position:absolute; z-index:50; left:50%; top:50%; transform:translate(-50%,-50%) scale(0.98); display:none; align-items:center; gap:10px; background:rgba(0,0,0,0.55); color:white; padding:12px 18px; border-radius:12px; font-weight:600; }
  .loader.show { display:flex; }

  /* auto toggle small UI */
  .auto-toggle { position:absolute; right:12px; top:12px; z-index:60; pointer-events:auto; display:flex; gap:8px; align-items:center; }
  .auto-btn { background: rgba(255,255,255,0.12); color:var(--accent); border:1px solid rgba(255,255,255,0.08); padding:6px 10px; border-radius:8px; font-weight:600; cursor:pointer; backdrop-filter: blur(4px); }
  .auto-ind { width:10px; height:10px; border-radius:50%; background:#9a9a9a; box-shadow: 0 0 6px rgba(0,0,0,0.6); }

  .auto-ind.on { background:#3ddc84; box-shadow: 0 0 8px rgba(61,220,132,0.4); }

  @media (max-width:420px){ .frame { width:280px; height:86px; } #result { font-size:16px; padding:10px; } .error-msg { font-size:13px; } }
</style>
</head>
<body>
  <div id="scanner" aria-label="Interface de scan OCR">
    <div class="topbar" aria-hidden="false">
      <div class="brand">
        <img src="logo.png" alt="Emballage BI logo" />
        <span>Emballage BI</span>
      </div>
      <div class="title">Scanneur rapide de numéros (OCR)</div>
    </div>

    <!-- petit UI pour activer/desactiver auto-scan -->
    <div class="auto-toggle" aria-hidden="false" style="pointer-events:auto;">
      <div id="autoIndicator" class="auto-ind" title="Statut auto-scan"></div>
      <button id="autoToggle" class="auto-btn" type="button" aria-pressed="true">Auto ON</button>
    </div>

    <div id="camera-wrapper" role="button" tabindex="0" aria-label="Appuyez pour capturer">
      <video id="video" autoplay playsinline></video>
      <div class="overlay"><div class="frame" aria-hidden="true"></div></div>
    </div>

    <div class="controls">
      <input id="result" type="text" inputmode="numeric" placeholder="Numéro détecté" aria-label="Numéro détecté, modifiable" />
      <button id="validate" type="button">Valider</button>
      <div id="errorMsg" class="error-msg" role="alert" aria-live="assertive">Il faut écrire ou détecter au moins un nombre dans le champ.</div>
    </div>

    <div class="loader" id="ocrLoader">Analyse en cours…</div>

    <canvas id="canvas" width="1280" height="720" style="display:none;"></canvas>
  </div>

  <script src="libs/tesseract.min.js"></script>
  <script>
    /* ======== éléments & état ======== */
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultInput = document.getElementById('result');
    const loader = document.getElementById('ocrLoader');
    const frameEl = document.querySelector('.frame');

    const autoToggleBtn = document.getElementById('autoToggle');
    const autoIndicator = document.getElementById('autoIndicator');

    let processing = false;
    let worker = null;
    let workerReady = false;
    let useWorker = !!(window.Tesseract && typeof Tesseract.createWorker === 'function');

    // auto-scan configuration (tu peux modifier l'intervalle ici)
    let autoScanEnabled = true;        // mode auto activé par défaut
    const AUTO_SCAN_INTERVAL_MS = 2000; // intervalle entre analyses en mode auto
    let autoScanTimer = null;

    /* ======== webcam ======== */
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => { video.srcObject = stream; })
      .catch(err => { console.error('webcam error:', err); alert("Impossible d'accéder à la caméra."); });

    function displayToVideoRect(videoEl, displayRect) {
      const vw = videoEl.videoWidth || 1280;
      const vh = videoEl.videoHeight || 720;
      const rectVid = videoEl.getBoundingClientRect();
      const cw = rectVid.width, ch = rectVid.height;
      const scale = Math.max(cw / vw, ch / vh);
      const scaledW = vw * scale, scaledH = vh * scale;
      const offsetX = (scaledW - cw) / 2, offsetY = (scaledH - ch) / 2;
      const dx = displayRect.left - rectVid.left, dy = displayRect.top - rectVid.top;
      const sx = (dx + offsetX) / scale, sy = (dy + offsetY) / scale;
      const sWidth = displayRect.width / scale, sHeight = displayRect.height / scale;
      const sx_c = Math.max(0, Math.min(sx, vw));
      const sy_c = Math.max(0, Math.min(sy, vh));
      const sw_c = Math.max(1, Math.min(sWidth, vw - sx_c));
      const sh_c = Math.max(1, Math.min(sHeight, vh - sy_c));
      return { sx: sx_c, sy: sy_c, sw: sw_c, sh: sh_c, vw, vh };
    }

    function imgDataToGray(idata){
      const d = idata.data;
      for (let i=0;i<d.length;i+=4){
          const r=d[i], g=d[i+1], b=d[i+2];
          const y = 0.299*r + 0.587*g + 0.114*b;
          d[i]=d[i+1]=d[i+2]=y;
      }
      return idata;
    }
    function applyThreshold(idata, threshold){
      const d = idata.data;
      for (let i=0;i<d.length;i+=4){
          const v = d[i] > threshold ? 255 : 0;
          d[i]=d[i+1]=d[i+2]=v;
      }
      return idata;
    }
    function invert(idata){
      const d = idata.data;
      for (let i=0;i<d.length;i+=4){
          d[i] = 255 - d[i]; d[i+1] = 255 - d[i+1]; d[i+2] = 255 - d[i+2];
      }
      return idata;
    }
    function estimateMeanGray(idata){
      const d = idata.data; let sum=0, n=0;
      for (let i=0;i<d.length;i+=4){ sum += d[i]; n++; }
      return sum / n;
    }

    /* ======== Tesseract worker initialisation ======== */
    async function initWorkerIfNeeded() {
      if (!useWorker) return;
      if (worker) return;
      if (!window.Tesseract || typeof Tesseract.createWorker !== 'function') {
          useWorker = false;
          return;
      }

      try {
          let candidate = Tesseract.createWorker();
          if (candidate && typeof candidate.then === 'function') {
            candidate = await candidate;
          }
          if (!candidate || typeof candidate.load !== 'function') {
            console.warn('createWorker returned non-standard object — fallback to Tesseract.recognize');
            useWorker = false;
            return;
          }
          worker = candidate;
          await worker.load();
          await worker.loadLanguage('eng');
          await worker.initialize('eng');
          await worker.setParameters({
              tessedit_char_whitelist: '0123456789()',
              tessedit_pageseg_mode: '6',
              preserve_interword_spaces: '1'
          });
          workerReady = true;
          console.log('Tesseract worker ready');
      } catch (e) {
          console.error('Worker init failed, using fallback', e);
          useWorker = false;
          worker = null;
          workerReady = false;
      }
    }

    async function waitWorkerReady(timeoutMs = 5000) {
      if (!useWorker) return;
      const start = Date.now();
      while (!workerReady) {
          if (Date.now() - start > timeoutMs) throw new Error('worker init timeout');
          await new Promise(r => setTimeout(r, 100));
      }
    }

    /* ======== capture + OCR ======== */
    async function startCapture(){
      // évite superposition d'analyses
      if (processing) return;
      processing = true;
      loader.classList.add('show');

      try {
          if (useWorker) initWorkerIfNeeded(); // lance l'init en tâche de fond si besoin
          if (useWorker) await waitWorkerReady();

          if (!video.videoWidth || !video.videoHeight) {
            await new Promise(res => { video.onloadedmetadata = res; setTimeout(res,200); });
          }

          const frameRect = frameEl.getBoundingClientRect();
          const srcRect = displayToVideoRect(video, frameRect);

          const targetH = Math.min(1200, Math.max(450, Math.round(srcRect.sh * 2.5)));
          const targetW = Math.round((srcRect.sw / srcRect.sh) * targetH);
          canvas.width = targetW; canvas.height = targetH;

          ctx.drawImage(video, srcRect.sx, srcRect.sy, srcRect.sw, srcRect.sh, 0, 0, canvas.width, canvas.height);
          const baseImage = ctx.getImageData(0,0,canvas.width,canvas.height);

          const a = new ImageData(new Uint8ClampedArray(baseImage.data), baseImage.width, baseImage.height);
          imgDataToGray(a);
          const contrast = 36;
          const f = (259*(contrast+255))/(255*(259-contrast));
          for (let i=0;i<a.data.length;i+=4){
            let v = a.data[i];
            v = f*(v-128)+128;
            v = Math.max(0, Math.min(255, v));
            a.data[i]=a.data[i+1]=a.data[i+2]=v;
          }
          const b = new ImageData(new Uint8ClampedArray(a.data), a.width, a.height);
          const mean = estimateMeanGray(b);
          const thresh = Math.max(80, Math.min(180, mean * 0.95));
          applyThreshold(b, thresh);
          const c = new ImageData(new Uint8ClampedArray(b.data), b.width, b.height);
          invert(c);

          const variants = [a,b,c];
          const results = [];

          for (let i=0;i<variants.length;i++){
            ctx.putImageData(variants[i], 0, 0);
            const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));
            if (!blob) continue;

            if (useWorker && worker) {
                try {
                  const res = await worker.recognize(blob);
                  const raw = (res.data && res.data.text) ? res.data.text : '';
                  const digits = (raw.match(/\d+/g) || []).join('');
                  let avgConf = 0;
                  if (res.data && Array.isArray(res.data.words) && res.data.words.length) {
                      avgConf = res.data.words.reduce((s,w)=>s + (w.confidence||0), 0) / res.data.words.length;
                  } else if (typeof res.data.confidence === 'number') {
                      avgConf = res.data.confidence;
                  }
                  results.push({digits, raw, conf: avgConf, variant: i});
                } catch (e) {
                  console.error('worker.recognize error', e);
                }
            } else {
                try {
                  const res = await Tesseract.recognize(blob, 'eng', { tessedit_char_whitelist: '0123456789' });
                  const raw = (res.data && res.data.text) ? res.data.text : '';
                  const digits = (raw.match(/\d+/g) || []).join('');
                  let avgConf = 0;
                  if (res.data && Array.isArray(res.data.words) && res.data.words.length) {
                      avgConf = res.data.words.reduce((s,w)=>s + (w.confidence||0), 0) / res.data.words.length;
                  }
                  results.push({digits, raw, conf: avgConf, variant: i});
                } catch (e) {
                  console.error('Tesseract.recognize fallback error', e);
                }
            }
          }

          // choisir meilleur match — priorité à pattern (dddd.. entre parenthèses)
          let bestMatch = '';
          let bestConf = 0;
          results.forEach(res => {
            const match = res.raw.match(/\((\d{4,6})\)/);
            if (match && match[1]) {
                const digits = match[1];
                if (res.conf > bestConf) {
                  bestMatch = digits;
                  bestConf = res.conf;
                }
            }
          });

          // si aucun résultat "parenthèses" on met le meilleur digits brut
          const fallbackDigits = results.sort((a,b)=> (b.conf||0)-(a.conf||0))[0]?.digits || '';
          resultInput.value = bestMatch || fallbackDigits;

      } catch (err) {
          console.error('capture error', err);
          // on évite d'alerter l'utilisateur sans raison, laisse console pour debug
      } finally {
          loader.classList.remove('show');
          processing = false;
      }
    }

    /* ======== gestion automatique (auto-scan) ======== */
    function updateAutoUI(){
      if (autoScanEnabled) {
        autoToggleBtn.textContent = 'Auto ON';
        autoToggleBtn.setAttribute('aria-pressed','true');
        autoIndicator.classList.add('on');
      } else {
        autoToggleBtn.textContent = 'Auto OFF';
        autoToggleBtn.setAttribute('aria-pressed','false');
        autoIndicator.classList.remove('on');
      }
    }

    function startAutoScan(){
      if (autoScanTimer) return;
      // immédiat + intervalle
      if (autoScanEnabled) {
        if (!processing) startCapture(); // capture instantanée
        autoScanTimer = setInterval(() => {
          if (!processing && autoScanEnabled && document.visibilityState === 'visible') {
            startCapture();
          }
        }, AUTO_SCAN_INTERVAL_MS);
      }
      updateAutoUI();
    }

    function stopAutoScan(){
      if (autoScanTimer) { clearInterval(autoScanTimer); autoScanTimer = null; }
      updateAutoUI();
    }

    // toggle au click sur bouton UI
    autoToggleBtn.addEventListener('click', () => {
      autoScanEnabled = !autoScanEnabled;
      if (autoScanEnabled) startAutoScan(); else stopAutoScan();
    });

    // démarre auto quand la video joue ; init worker en fond
    video.addEventListener('playing', () => {
      initWorkerIfNeeded().catch(()=>{/* noop */});
      if (autoScanEnabled) startAutoScan();
    });

    // pause l'auto-scan quand onglet caché (préserve batterie)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState !== 'visible') {
        if (autoScanTimer) { clearInterval(autoScanTimer); autoScanTimer = null; }
      } else {
        if (autoScanEnabled) startAutoScan();
      }
    });

    /* bind capture au click/tap (on garde la fonctionnalité manuelle) */
    const cameraWrapper = document.getElementById('camera-wrapper');
    cameraWrapper.addEventListener('click', () => startCapture());
    cameraWrapper.addEventListener('touchstart', (e) => { e.preventDefault(); startCapture(); }, {passive:false});

    /* ======== validation / navigation ======== */
    const validateBtn = document.getElementById('validate');
    const errorMsg = document.getElementById('errorMsg');

    function showValidationError(text) {
      errorMsg.textContent = text || 'Il faut écrire ou détecter au moins un nombre dans le champ.';
      errorMsg.classList.add('show');
      resultInput.classList.add('invalid');
    }
    function clearValidationError() {
      errorMsg.classList.remove('show');
      resultInput.classList.remove('invalid');
    }

    function validateAndRedirect() {
      const val = (resultInput.value || '').trim();
      if (/\d/.test(val)) {
        // avant de partir, on peut arrêter worker pour libérer mémoire
        try { if (worker && typeof worker.terminate === 'function') worker.terminate(); } catch(e){}
        window.location.href = 'newplaque.html';
      } else {
        showValidationError('Il faut écrire ou détecter au moins un nombre dans le champ.');
        resultInput.focus();
      }
    }

    validateBtn.addEventListener('click', validateAndRedirect);
    resultInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); validateAndRedirect(); } });
    resultInput.addEventListener('input', () => {
      if (resultInput.classList.contains('invalid')) {
        if (/\d/.test(resultInput.value || '')) clearValidationError();
      }
    });

    /* cleanup worker */
    window.addEventListener('beforeunload', async () => {
      try { if (worker) await worker.terminate(); } catch(e){/*ignore*/ }
    });

    /* initial UI state */
    updateAutoUI();

    /* Optionnel: démarrage auto si la video était déjà prête */
    if (video.readyState >= 2 && autoScanEnabled) {
      // si la cam est déjà prête
      initWorkerIfNeeded().catch(()=>{/*noop*/});
      startAutoScan();
    }
  </script>
</body>
</html>
